## 1. Σωροί (Heaps) - Ορισμός και Διαφορές

Ο σωρός είναι πλήρες δυαδικό δέντρο όπου το κλειδί κάθε κόμβου ικανοποιεί συγκεκριμένη σχέση με τα παιδιά του.

### Διαφορά Max Heap και Min Heap

**Max Heap**: Η τιμή κάθε γονικού κόμβου είναι μεγαλύτερη ή ίση από τις τιμές των παιδιών του, με τη μέγιστη τιμή στη ρίζα.

**Min Heap**: Η τιμή κάθε γονικού κόμβου είναι μικρότερη ή ίση από τις τιμές των παιδιών του, με την ελάχιστη τιμή στη ρίζα.

### Διατήρηση Ιδιότητας Σωρού

**Εισαγωγή**: Το νέο στοιχείο τοποθετείται στο τέλος του σωρού. Ακολουθεί η διαδικασία heapify που συγκρίνει το στοιχείο με τον γονέα του και τα εναλλάσσει αν παραβιάζεται η ιδιότητα του σωρού, επαναλαμβάνοντας μέχρι να αποκατασταθεί η ιδιότητα.

**Διαγραφή**: Συνήθως διαγράφεται η ρίζα (μέγιστο/ελάχιστο). Το τελευταίο στοιχείο μετακινείται στη ρίζα και η διαδικασία heapify συγκρίνει το στοιχείο με τα παιδιά του, εναλλάσσοντάς το με το μεγαλύτερο (max heap) ή μικρότερο (min heap) παιδί, επαναλαμβάνοντας μέχρι να αποκατασταθεί η ιδιότητα.


## 2. Σωροί και Ουρές Προτεραιοτήτων

### Γιατί οι Σωροί είναι Κατάλληλοι;

Οι σωροί (heaps) θεωρούνται κατάλληλοι για την υλοποίηση ουρών προτεραιότητας (priority queues) λόγω της ιδιότητας διάταξης (heap order), που εξασφαλίζει ότι η ρίζα περιέχει πάντα το μέγιστο ή ελάχιστο στοιχείο, επιτρέποντας γρήγορη εξαγωγή του. Επιπλέον, οι βασικές λειτουργίες εισαγωγής και διαγραφής εκτελούνται σε χρόνο O(log N), ενώ η αρχική κατασκευή γίνεται σε O(N), καθιστώντας τους αποδοτικούς για μεγάλες συλλογές δεδομένων.

### Παραδείγματα Πραγματικών Εφαρμογών

1. Χρονοπρογραμματισμός Εργασιών: Σε λειτουργικά συστήματα, οι διεργασίες/threads διατηρούνται σε ουρά προτεραιότητας με κλειδιά τις προτεραιότητές τους, επιτρέποντας γρήγορη επιλογή της επόμενης διεργασίας προς εκτέλεση.​

2. Αλγόριθμος Dijkstra: Για εύρεση συντομότερων μονοπατιών σε γράφους, χρησιμοποιείται priority queue για να επιλέγεται πάντα ο κόμβος με την ελάχιστη απόσταση προς επεξεργασία.


## 3. Συνάρτηση Κατακερματισμού (Hash Function)
Μια **συνάρτηση κατακερματισμού** είναι μια μαθηματική συνάρτηση που παίρνει έναν αριθμό αυθαίρετου μεγέθους (κλειδί) και παράγει έναν ακέραιο αριθμό σταθερού μεγέθους (hash value), που δείχνει μια θέση στον πίνακα κατακερματισμού.

### Χαρακτηριστικά Αποδοτικής Συνάρτησης Κατακερματισμού

**1. Ντετερμινιστική:**
- Το ίδιο κλειδί παράγει πάντα την ίδια τιμή hash
- Εάν h(x) = 5 σήμερα, h(x) = 5 πάντα

**2. Ομοιόμορφη Κατανομή:**
- Τα hash values κατανέμονται ομοιόμορφα στο χώρο
- Αποφεύγει συγκεντρώσεις (clustering) που δημιουργούν συγκρούσεις

**3. Γρήγορη Υπολογισμός:**
- Ο χρόνος υπολογισμού πρέπει να είναι O(1) ή O(|key|)
- Δεν πρέπει να είναι περισσότερο χρονοβόρα από τη λειτουργία που προκαλεί

**4. Ελαχιστοποίηση Συγκρούσεων:**
- Διαφορετικά κλειδιά πρέπει να παράγουν διαφορετικές τιμές hash
- Πρακτικά αδύνατο για όλα τα κλειδιά, αλλά πρέπει να ελαχιστοποιηθούν

**5. Κανονικοποίηση Εξόδου:**
- h(key) mod table_size εξασφαλίζει ότι το αποτέλεσμα είναι εντός ορίων

```python
class HashFunction:
    def __init__(self, table_size):
        self.table_size = table_size
    
    def python_hash(self, key):
        return hash(key) % self.table_size
    
    # Polynomial rolling hash (custom implementation)
    def polynomial_hash(self, key, base=31):
        hash_value = 0
        for char in key:
            hash_value = (hash_value * base + ord(char)) % self.table_size
        return hash_value
    
    # Using hash() with absolute value for consistency
    def stable_hash(self, key):
        return abs(hash(key)) % self.table_size

# Example usage
hasher = HashFunction(table_size=10)
print(f"python_hash('apple'): {hasher.python_hash('apple')}")
print(f"stable_hash('apple'): {hasher.stable_hash('apple')}")
print(f"polynomial_hash('apple'): {hasher.polynomial_hash('apple')}")
print(f"python_hash(123): {hasher.python_hash(123)}")
```

## 4. Στρατηγικές Επίλυσης Συγκρούσεων
## Chaining (Αλυσίδωση)

Δημιουργεί συνδεδεμένη λίστα στοιχείων με ίδιο hash στην ίδια θέση πίνακα.

**Πλεονεκτήματα:**
- Απλή υλοποίηση
- Δεν γεμίζει ποτέ ο πίνακας - δεν υπάρχει όριο στοιχείων
- Αποδοτική για υψηλό συντελεστή φόρτωσης (λ)
- Εύκολη διαγραφή στοιχείων

**Μειονεκτήματα:**
- Απαιτεί επιπλέον μνήμη για pointers/δείκτες
- Κακή χρήση cache (μη συνεχόμενη μνήμη)
- Χειρότερη απόδοση αν οι λίστες μεγαλώσουν πολύ

## Open Addressing (Ανοιχτή Διευθυνσιοδότηση)

Εφαρμόζει δευτερεύουσα συνάρτηση κατακερματισμού συνεχώς μέχρι να βρεθεί κενή θέση. Περιλαμβάνει γραμμική/τετραγωνική ανίχνευση και διπλό κατακερματισμό.

**Πλεονεκτήματα:**
- Δεν απαιτεί επιπλέον μνήμη για pointers
- Καλύτερη cache performance (συνεχόμενη μνήμη)
- Για διπλό κατακερματισμό: αποφεύγει primary/secondary clustering, προσεγγίζει βέλτιστο κόστος αναζήτησης

**Μειονεκτήματα:**
- Ο πίνακας γεμίζει (περιορισμένο μέγεθος)
- Χειρότερη απόδοση με υψηλό λ
- Για διπλό κατακερματισμό: απαιτεί επιπλέον υπολογισμό hash
- Πιο πολύπλοκη διαγραφή


## 5. Κωδικοποίηση Huffman
