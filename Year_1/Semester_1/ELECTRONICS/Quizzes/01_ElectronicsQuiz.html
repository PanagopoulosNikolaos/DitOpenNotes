<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Electronics MCQ Game (Ohm’s Law & Basics)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0f1226;
    --panel:#161a36;
    --accent:#7c5cff;
    --accent2:#12d7d0;
    --accent3:#ff6e6e;
    --text:#eef1ff;
    --muted:#9aa1c6;
    --correct:#11d676;
    --wrong:#ff4d6d;
    --gold:#ffd166;
  }
  html,body{
    margin:0; padding:0; height:100%; background: radial-gradient(1200px 600px at 30% 10%, rgba(124,92,255,.35), transparent 50%),
                                     radial-gradient(800px 500px at 80% 0%, rgba(18,215,208,.25), transparent 50%),
                                     var(--bg);
    color:var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }
  .app{
    max-width:1000px; margin:0 auto; padding:24px;
  }
  .title{
    font-size:28px; font-weight:800; letter-spacing:.3px;
    background: linear-gradient(90deg, var(--gold), var(--accent2), var(--accent));
    -webkit-background-clip: text; background-clip: text; color: transparent;
    margin:10px 0 6px;
  }
  .subtitle{
    color:var(--muted); margin:0 0 18px; font-size:14px;
  }
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:18px 18px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
  }
  .hud{
    display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:10px;
  }
  .badge{
    background: linear-gradient(180deg, rgba(124,92,255,.25), rgba(124,92,255,.08));
    border:1px solid rgba(124,92,255,.35);
    color:#ded9ff; padding:8px 10px; border-radius:10px; font-weight:700; font-size:12px;
  }
  .badge.alt{ background: linear-gradient(180deg, rgba(18,215,208,.25), rgba(18,215,208,.08)); border-color: rgba(18,215,208,.35); color:#d6fffb; }
  .badge.warn{ background: linear-gradient(180deg, rgba(255,110,110,.25), rgba(255,110,110,.08)); border-color: rgba(255,110,110,.35); color:#ffe6e6; }

  /* Progress bar moved under HUD (question count) */
  .progress{
    height:10px; background: rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin:6px 0 14px;
    border:1px solid rgba(255,255,255,.08);
  }
  .bar{ height:100%; width:0%; background: linear-gradient(90deg, var(--accent2), var(--accent)); transition: width .3s ease; }

  .question{
    font-size:18px; font-weight:700; line-height:1.35; margin:8px 0 12px;
  }
  .canvas-wrap{
    margin:10px 0 16px; background: #0c0f24; border:1px solid rgba(255,255,255,.07); border-radius:12px; padding:10px;
  }
  .options{
    display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px;
  }
  .option{
    position:relative;
    border:1px solid rgba(255,255,255,.1); background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
    color:var(--text); padding:12px 14px; border-radius:12px; cursor:pointer;
    transition: transform .08s ease, border-color .15s ease, background .2s ease;
    font-weight:700;
  }
  .option:hover{ transform: translateY(-1px); border-color: rgba(124,92,255,.55); background: linear-gradient(180deg, rgba(124,92,255,.14), rgba(124,92,255,.06)); }
  .option.correct{ border-color: rgba(17,214,118,.75); background: linear-gradient(180deg, rgba(17,214,118,.18), rgba(17,214,118,.06)); }
  .option.wrong{ border-color: rgba(255,77,109,.8); background: linear-gradient(180deg, rgba(255,77,109,.18), rgba(255,77,109,.06)); }
  .controls{ display:flex; gap:10px; align-items:center; margin-top:16px; }
  .btn{
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    color:#0b0e1f; font-weight:900; border:none; padding:10px 14px; border-radius:10px; cursor:pointer;
    letter-spacing:.3px; box-shadow: 0 6px 18px rgba(124,92,255,.35); transition: transform .08s ease, box-shadow .2s ease;
  }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  .btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 24px rgba(124,92,255,.45); }
  .explain{
    margin-top:12px; color:#d6dbff; background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:12px; font-size:14px;
  }
  .pill{ font-size:11px; color:var(--muted); }
  .footer{
    margin-top:18px; font-size:12px; color:var(--muted);
  }
  .score{ font-weight:900; color:var(--gold); }
  .math{ font-weight:800; color:#fefbff; }
  @media(min-width:720px){
    .options{ grid-template-columns: 1fr 1fr; }
  }
</style>
</head>
<body>
<div class="app">
  <div class="title">Electronics Multiple Choice Game</div>
  <div class="subtitle">Ohm’s Law, components, sources, signals, and fundamentals with LaTeX and inline plots</div>

  <div class="card">
    <div class="hud">
      <div class="badge">Question <span id="qNum">1</span> / <span id="qTotal">40</span></div>
      <div class="badge alt">Score: <span class="score" id="score">0</span></div>
      <div class="badge warn pill">Tip: Click an option to check; use Next to skip or continue</div>
    </div>

    <!-- Progress bar repositioned directly under HUD -->
    <div class="progress" aria-label="Progress">
      <div class="bar" id="bar"></div>
    </div>

    <div id="question" class="question"></div>
    <div id="plot" class="canvas-wrap" style="display:none;">
      <canvas id="qCanvas" width="900" height="260"></canvas>
    </div>
    <div id="options" class="options"></div>

    <div class="controls">
      <!-- Next is always enabled to allow skipping -->
      <button id="next" class="btn">Next</button>
      <button id="restart" class="btn" style="display:none;">Restart</button>
    </div>

    <div class="explain" id="explain" style="display:none;"></div>
    <div class="footer" id="footerNote"></div>
  </div>
</div>

<!-- MathJax for LaTeX rendering -->
<script>
  // Correct MathJax v3 config: use single backslash in string literals for delimiters
  window.MathJax = {
    tex: { inlineMath: [['\\(','\\)']], displayMath: [['\\[','\\]']] },
    svg: { fontCache: 'global' }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>

<script>
/*
Question Schema:
{
  text: "string with LaTeX like \\( V = IR \\)",
  choices: ["A","B","C","D"],
  correctIndex: 0..3,
  explain: "string with LaTeX",
  plot: { type:'iv'|'rc'|'acdc'|'cv_energy'|'li_energy', params:{...} }
}
All content is aligned to the attached PDF topics.
*/

const questions = [
  { text: "Which particles carry negative charge in an atom?", choices: ["Protons", "Electrons", "Neutrons", "Ions in the nucleus"], correctIndex: 1, explain: "Electrons carry negative charge, protons positive, and neutrons are neutral." },
  { text: "Which statement best describes an electrical conductor?", choices: ["Material with no charge carriers available","Material allowing oriented motion of charges easily","Material with very large band gap","Material where only holes can move"], correctIndex: 1, explain: "Conductors allow oriented motion of charges due to available carriers and overlapping bands." },
  { text: "Semiconductors have an energy band gap that is:", choices: ["Zero (bands overlap fully)","Very large, prohibiting carriers","Relatively small, enabling thermal excitation","Negative"], correctIndex: 2, explain: "Semiconductors have a modest band gap so small energy (e.g., thermal) can excite carriers to the conduction band." },
  { text: "Electric current is defined as \\( I = \\frac{dQ}{dt} \\). What does \\(Q\\) represent?", choices: ["Potential energy","Electric field","Electric charge","Resistance"], correctIndex: 2, explain: "Current is the rate of flow of electric charge \\( I = \\frac{dQ}{dt} \\)." },
  { text: "Voltage between two points is best described as:", choices: ["Charge per unit time","Energy per unit charge (potential difference)","Force per unit charge","Charge density"], correctIndex: 1, explain: "Voltage (potential difference) is energy per unit charge between two points." },
  { text: "Conventional current direction is defined as:", choices: ["Same as electron flow","From negative to positive terminal","From positive to negative terminal","From ground to source automatically"], correctIndex: 2, explain: "By convention, current direction is from higher potential (positive) to lower (negative), opposite to electron flow." },
  { text: "In circuit measurements, the 'COM' terminal of a voltmeter connects to:", choices: ["Highest potential node","Arbitrary floating node","The reference (ground) node","The source’s positive terminal"], correctIndex: 2, explain: "COM connects to the reference (ground) node so voltages are measured relative to the same potential." },
  { text: "Ohm’s law in its common form is:", choices: ["\\( I = VR \\)","\\( V = IR \\)","\\( R = VI \\)","\\( P = VI \\)"], correctIndex: 1, explain: "Ohm’s law relates voltage, current, and resistance: \\( V = I R \\)." },
  { text: "The I–V characteristic of an ideal resistor is:", choices: ["Parabola","Exponential","Straight line through origin","Sine wave"], correctIndex: 2, explain: "For a resistor, \\( I = \\frac{V}{R} \\) yields a straight-line I–V relation through the origin; slope is \\(1/R\\).", plot: { type:"iv", params:{ R: 100 } } },
  { text: "Conductance is defined as:", choices: ["\\( g = R \\)","\\( g = \\frac{1}{R} \\)","\\( g = VR \\)","\\( g = IR \\)"], correctIndex: 1, explain: "Conductance is the reciprocal of resistance: \\( g = \\frac{1}{R} \\), so \\( I = g V \\)." },
  { text: "Equivalent resistance in series is:", choices: ["\\( R_{eq} = \\sum R_i \\)","\\( \\frac{1}{R_{eq}} = \\sum \\frac{1}{R_i} \\)","\\( R_{eq} = \\min(R_i) \\)","\\( R_{eq} = \\max(R_i) \\)"], correctIndex: 0, explain: "Series resistors add directly: \\( R_{eq} = R_1 + R_2 + \\cdots + R_n \\)." },
  { text: "Equivalent resistance in parallel is:", choices: ["\\( R_{eq} = \\sum R_i \\)","\\( \\frac{1}{R_{eq}} = \\sum \\frac{1}{R_i} \\)","\\( R_{eq} = R_1 R_2 \\)","\\( R_{eq} = R_1 - R_2 \\)"], correctIndex: 1, explain: "Parallel resistors add as conductances: \\( \\frac{1}{R_{eq}} = \\sum_i \\frac{1}{R_i} \\)." },
  { text: "Capacitance is given by:", choices: ["\\( C = \\frac{V}{Q} \\)","\\( C = \\frac{Q}{V} \\)","\\( C = QV \\)","\\( C = \\frac{1}{QV} \\)"], correctIndex: 1, explain: "By definition, \\( C = \\frac{Q}{V} \\)." },
  { text: "Energy stored in a capacitor is:", choices: ["\\( W = C V^2 \\)","\\( W = \\tfrac{1}{2} C V^2 \\)","\\( W = \\tfrac{1}{2} \\frac{V}{C} \\)","\\( W = Q^2 C \\)"], correctIndex: 1, explain: "Capacitor energy: \\( W = \\tfrac{1}{2} C V^2 \\).", plot: { type:"cv_energy", params:{ C: 1e-6, Vmax: 10 } } },
  { text: "For an RC circuit, the time constant is:", choices: ["\\( \\tau = \\frac{R}{C} \\)","\\( \\tau = RC \\)","\\( \\tau = \\frac{1}{RC} \\)","\\( \\tau = R + C \\)"], correctIndex: 1, explain: "The RC time constant is \\( \\tau = RC \\); about \\(5\\tau\\) to charge near full." },
  { text: "A typical capacitor charging curve (voltage vs. time) follows:", choices: ["Linear increase","Exponential approach to final value","Sinusoidal oscillation","Parabolic growth"], correctIndex: 1, explain: "Charging in an RC circuit is exponential with time constant \\(\\tau=RC\\); near full at about \\(5\\tau\\).", plot: { type:"rc", params:{ V: 5, R: 10000, C: 10e-6 } } },
  { text: "Placing a dielectric between capacitor plates primarily:", choices: ["Decreases capacitance","Increases capacitance","Leaves capacitance unchanged","Always damages the capacitor"], correctIndex: 1, explain: "A dielectric increases capacitance; dielectric strength defines the max field before breakdown." },
  { text: "Equivalent capacitance for series capacitors is:", choices: ["\\( C_{eq} = \\sum C_i \\)","\\( \\frac{1}{C_{eq}} = \\sum \\frac{1}{C_i} \\)","\\( C_{eq} = C_1 C_2 \\)","\\( C_{eq} = C_1 - C_2 \\)"], correctIndex: 1, explain: "Series capacitors combine via reciprocals: \\( \\tfrac{1}{C_{eq}} = \\sum_i \\tfrac{1}{C_i} \\)." },
  { text: "Equivalent capacitance for parallel capacitors is:", choices: ["\\( C_{eq} = \\sum C_i \\)","\\( \\frac{1}{C_{eq}} = \\sum \\frac{1}{C_i} \\)","\\( C_{eq} = \\min(C_i) \\)","\\( C_{eq} = \\max(C_i) \\)"], correctIndex: 0, explain: "Parallel capacitors add directly: \\( C_{eq} = C_1 + C_2 + \\cdots + C_n \\)." },
  { text: "The induced voltage across an inductor opposes the change in current by:", choices: ["Faraday’s law only","Lenz’s law","Coulomb’s law","Kirchhoff’s current law"], correctIndex: 1, explain: "Lenz’s law states the induced EMF opposes the change that produced it." },
  { text: "Energy stored in an inductor is:", choices: ["\\( E = L I^2 \\)","\\( E = \\tfrac{1}{2} L I^2 \\)","\\( E = \\tfrac{1}{2} \\frac{I}{L} \\)","\\( E = \\tfrac{1}{2} LI \\)"], correctIndex: 1, explain: "Inductor energy: \\( E = \\tfrac{1}{2} L I^2 \\).", plot: { type:"li_energy", params:{ L: 0.1, Imax: 2.0 } } },
  { text: "Inductors in series combine as:", choices: ["\\( L_{eq} = \\sum L_i \\)","\\( \\frac{1}{L_{eq}} = \\sum \\frac{1}{L_i} \\)","\\( L_{eq} = L_1 L_2 \\)","\\( L_{eq} = L_1 - L_2 \\)"], correctIndex: 0, explain: "Series inductances add directly: \\( L_{eq} = L_1 + L_2 + \\cdots + L_n \\)." },
  { text: "Inductors in parallel combine as:", choices: ["\\( L_{eq} = \\sum L_i \\)","\\( \\frac{1}{L_{eq}} = \\sum \\frac{1}{L_i} \\)","\\( L_{eq} = L_1 L_2 \\)","\\( L_{eq} = L_1 - L_2 \\)"], correctIndex: 1, explain: "Parallel inductors combine via reciprocals: \\( \\tfrac{1}{L_{eq}} = \\sum_i \\tfrac{1}{L_i} \\)." },
  { text: "Analog signals are characterized by being:", choices: ["Discrete in time and amplitude","Continuous in time and amplitude","Only binary-valued","Always periodic"], correctIndex: 1, explain: "Analog signals are continuous-time and continuous-amplitude." },
  { text: "A DC signal maintains constant sign over time; an AC signal:", choices: ["Also keeps sign constant","Alternates polarity over time","Is always noise","Is constant zero"], correctIndex: 1, explain: "AC alternates polarity; DC maintains a constant sign.", plot: { type:"acdc", params:{ Vdc: 2.0, Vac: 2.0, f: 1 } } },
  { text: "A practical voltage source with internal resistance \\(r\\) approximates an ideal source when:", choices: ["\\( r \\gg R_L \\)","\\( r \\approx R_L \\)","\\( r \\ll R_L \\)","\\( r = 0 \\) only"], correctIndex: 2, explain: "When \\( r \\ll R_L \\), load voltage approximates the nominal source voltage (ideal behavior is \\( r \\to 0 \\))." },
  { text: "A key spec of a voltage source (supply) is its maximum deliverable current \\(I_{max}\\). Exceeding it typically:", choices: ["Increases voltage","Decreases or limits voltage/output, risking faults","Harms the load only","Has no effect"], correctIndex: 1, explain: "Beyond \\(I_{max}\\), a supply may sag, limit, or shut down; operating beyond ratings risks faults." },
  { text: "For series-connected voltage sources, overall nominal voltage is the sum, and the allowable current is limited by:", choices: ["Sum of all \\(I_{max}\\)","Average of \\(I_{max}\\)","The smallest \\(I_{max}\\) among them","The largest \\(I_{max}\\)"], correctIndex: 2, explain: "In series, voltages add but current must not exceed the most restrictive source’s \\(I_{max}\\)." },
  { text: "Parallel connection of ideal voltage sources with different voltages is:", choices: ["Allowed with no issue","Not allowed (conflicting enforced voltages)","Always safe with diodes","Required for high current"], correctIndex: 1, explain: "Ideal voltage sources of different values cannot be paralleled, as they enforce different node voltages." },
  { text: "Parallel identical voltage sources (same nominal V) ideally provide:", choices: ["Higher voltage, same \\(I_{max}\\)","Same voltage, higher \\(I_{max}\\)","Lower voltage, lower \\(I_{max}\\)","Higher voltage and higher resistance"], correctIndex: 1, explain: "Paralleling identical voltage sources keeps voltage the same but increases available current." },
  { text: "A practical current source approximates ideal behavior when its internal resistance relative to the load is:", choices: ["\\( r \\ll R_L \\)","\\( r \\approx R_L \\)","\\( r \\gg R_L \\)","\\( r = 0 \\)"], correctIndex: 2, explain: "For current sources, \\( r \\gg R_L \\) makes current nearly independent of load; ideal is \\( r \\to \\infty \\)." },
  { text: "A practical current source often specifies a minimum compliance voltage \\(V_{min}\\) meaning:", choices: ["It cannot operate below a certain current","It needs at least \\(V_{min}\\) across it to maintain the set current","It produces negative voltage only","It limits to zero current always"], correctIndex: 1, explain: "Compliance voltage is the minimum voltage required for the source to keep the programmed current." },
  { text: "Series connection of current sources ideally results in:", choices: ["Sum of voltages and min current","Sum of currents and same voltage","Same current, voltages add as needed","Zero current"], correctIndex: 2, explain: "In series, the same current flows; voltages adjust (subject to compliance limits)." },
  { text: "Parallel connection of current sources ideally results in:", choices: ["Currents adding (same voltage at output)","Voltages adding","Current halving","No change"], correctIndex: 0, explain: "Parallel current sources add their currents while imposing the same output voltage." },
  { text: "In an I–V plot for a resistor, the slope of \\(I\\) vs. \\(V\\) equals:", choices: ["\\( R \\)","\\( \\tfrac{1}{R} \\)","\\( V \\)","\\( I \\)"], correctIndex: 1, explain: "From \\( I = \\frac{V}{R} \\), slope \\( dI/dV = 1/R \\).", plot: { type:"iv", params:{ R: 50 } } },
  { text: "In insulators, the band gap between valence and conduction bands is:", choices: ["Negligible (bands overlap)","Large, preventing electron excitation to conduction band","Zero","Undefined"], correctIndex: 1, explain: "A large band gap prevents significant carrier excitation, yielding insulating behavior." },
  { text: "Common schematic annotation for DC vs. AC signals is:", choices: ["DC: ~ , AC: —","DC: — , AC: ~","Both use ~","Both use —"], correctIndex: 1, explain: "A wavy tilde ~ is used for AC, while a straight line denotes DC." },
  { text: "Choosing the ground node in a circuit primarily establishes:", choices: ["A literal earth connection","The reference potential (0 V) for all node voltages","Maximum current path","Shortest path"], correctIndex: 1, explain: "Ground is the reference node at 0 V used to measure all other node voltages." },
  { text: "From the Ohm’s law triangle, the correct rearrangements include:", choices: ["\\( I = VR \\) and \\( R = VI \\)","\\( I = \\tfrac{V}{R} \\) and \\( R = \\tfrac{V}{I} \\)","\\( V = \\tfrac{I}{R} \\) only","\\( V = R - I \\)"], correctIndex: 1, explain: "Valid forms: \\( V = IR \\), \\( I = \\tfrac{V}{R} \\), and \\( R = \\tfrac{V}{I} \\)." },
  { text: "Energy in reactive elements compares as:", choices: ["Cap: \\( \\tfrac{1}{2} C V^2 \\); Ind: \\( \\tfrac{1}{2} L I^2 \\)","Cap: \\( C V \\); Ind: \\( L I \\)","Cap: \\( \\tfrac{1}{2} C I^2 \\); Ind: \\( \\tfrac{1}{2} L V^2 \\)","Both zero at all times"], correctIndex: 0, explain: "Capacitor stores in electric field: \\( \\tfrac{1}{2} C V^2 \\); inductor stores in magnetic field: \\( \\tfrac{1}{2} L I^2 \\)." },
];

const elQ = document.getElementById('question');
const elOptions = document.getElementById('options');
const elExplain = document.getElementById('explain');
const elNext = document.getElementById('next');
const elRestart = document.getElementById('restart');
const elBar = document.getElementById('bar');
const elQNum = document.getElementById('qNum');
const elQTotal = document.getElementById('qTotal');
const elScore = document.getElementById('score');
const elPlotWrap = document.getElementById('plot');
const elFooter = document.getElementById('footerNote');

elQTotal.textContent = questions.length.toString();

let idx = 0;
let score = 0;
let answeredThis = false; // track if current question was answered

function resetState(){
  answeredThis = false;
  elExplain.style.display = 'none';
  elExplain.innerHTML = '';
  elPlotWrap.style.display = 'none';
  elFooter.textContent = '';
  elOptions.innerHTML = '';
}

function renderMath(){
  if (window.MathJax && window.MathJax.typesetPromise){
    window.MathJax.typesetPromise();
  }
}

function drawAxes(ctx, x, y, w, h, xlabel, ylabel){
  ctx.save();
  ctx.translate(x, y);
  ctx.strokeStyle = '#5d6aa3';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h); ctx.lineTo(0, 0); // y
  ctx.moveTo(0, h); ctx.lineTo(w, h); // x
  ctx.stroke();
  ctx.fillStyle = '#b9c3ff';
  ctx.font = '12px system-ui, sans-serif';
  ctx.fillText(xlabel, w-20, h-6);
  ctx.fillText(ylabel, 6, 12);
  ctx.restore();
}

function plotIV(R){
  const cvs = document.getElementById('qCanvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const pad = 42, w = cvs.width - pad*2, h = cvs.height - pad*2;
  drawAxes(ctx, pad, pad, w, h, 'V', 'I');
  ctx.save();
  ctx.translate(pad, pad);
  ctx.strokeStyle = '#12d7d0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const Vmax = 10;
  for(let i=0;i<=100;i++){
    const V = Vmax*i/100;
    const I = V/R;
    const px = (V/Vmax)*w;
    const Imax = Vmax/R;
    const py = h - (I/Imax)*h;
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.fillStyle = '#9aa1c6';
  ctx.font = '12px system-ui';
  ctx.fillText(`R = ${R} Ω`, 10, 16);
  ctx.restore();
}

function plotRC(V, R, C){
  const cvs = document.getElementById('qCanvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const pad = 42, w = cvs.width - pad*2, h = cvs.height - pad*2;
  drawAxes(ctx, pad, pad, w, h, 't', 'Vc');
  ctx.save();
  ctx.translate(pad, pad);
  const tau = R*C;
  const tmax = 5*tau;
  ctx.strokeStyle = '#7c5cff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<=200;i++){
    const t = tmax*i/200;
    const Vc = V*(1 - Math.exp(-t/tau));
    const px = (t/tmax)*w;
    const py = h - (Vc/V)*h;
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.fillStyle = '#9aa1c6';
  ctx.font = '12px system-ui';
  ctx.fillText(`V = ${V.toFixed(2)} V, R = ${R} Ω, C = ${C} F, τ = ${(tau).toFixed(3)} s`, 10, 16);
  ctx.strokeStyle = 'rgba(255,255,255,.2)';
  ctx.setLineDash([4,3]);
  for(let k=1;k<=5;k++){
    const x = (k*tau/tmax)*w;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  }
  ctx.restore();
}

function plotACDC(Vdc, Vac){
  const cvs = document.getElementById('qCanvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const pad = 42, w = cvs.width - pad*2, h = cvs.height - pad*2;
  drawAxes(ctx, pad, pad, w, h, 't', 'v(t)');
  ctx.save();
  ctx.translate(pad, pad);

  // DC line
  ctx.strokeStyle = '#ffd166';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<=200;i++){
    const t = i/200;
    const v = Vdc;
    const px = t*w;
    const py = h - 0.5*h; // center the DC line visually
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();

  // AC sine
  ctx.strokeStyle = '#ff6e6e';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<=400;i++){
    const t = i/200; // 0..2
    const v = Vac*Math.sin(2*Math.PI*t);
    const px = (t/2)*w;
    const py = h - ((v + Vac)/(2*Vac))*h;
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();

  ctx.fillStyle = '#9aa1c6';
  ctx.font = '12px system-ui';
  ctx.fillText(`DC (gold): ${Vdc.toFixed(1)} V,  AC (red): ±${Vac.toFixed(1)} V`, 10, 16);
  ctx.restore();
}

function plotCapEnergy(C, Vmax){
  const cvs = document.getElementById('qCanvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const pad = 42, w = cvs.width - pad*2, h = cvs.height - pad*2;
  drawAxes(ctx, pad, pad, w, h, 'V', 'W');
  ctx.save();
  ctx.translate(pad, pad);
  ctx.strokeStyle = '#12d7d0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const Wmax = 0.5*C*Vmax*Vmax;
  for(let i=0;i<=200;i++){
    const V = Vmax*i/200;
    const W = 0.5*C*V*V;
    const px = (V/Vmax)*w;
    const py = h - (W/Wmax)*h;
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.fillStyle = '#9aa1c6';
  ctx.font = '12px system-ui';
  ctx.fillText(`W = 1/2 C V^2,  C=${C} F`, 10, 16);
  ctx.restore();
}

function plotIndEnergy(L, Imax){
  const cvs = document.getElementById('qCanvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,cvs.width,cvs.height);
  const pad = 42, w = cvs.width - pad*2, h = cvs.height - pad*2;
  drawAxes(ctx, pad, pad, w, h, 'I', 'E');
  ctx.save();
  ctx.translate(pad, pad);
  ctx.strokeStyle = '#7c5cff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const Emax = 0.5*L*Imax*Imax;
  for(let i=0;i<=200;i++){
    const I = Imax*i/200;
    const E = 0.5*L*I*I;
    const px = (I/Imax)*w;
    const py = h - (E/Emax)*h;
    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.fillStyle = '#9aa1c6';
  ctx.font = '12px system-ui';
  ctx.fillText(`E = 1/2 L I^2,  L=${L} H`, 10, 16);
  ctx.restore();
}

function renderPlot(plot){
  if(!plot){ elPlotWrap.style.display='none'; return; }
  elPlotWrap.style.display = 'block';
  const {type, params} = plot;
  if(type === 'iv'){ plotIV(params.R ?? 100); }
  else if(type === 'rc'){ plotRC(params.V ?? 5, params.R ?? 1000, params.C ?? 1e-6); }
  else if(type === 'acdc'){ plotACDC(params.Vdc ?? 2, params.Vac ?? 2); }
  else if(type === 'cv_energy'){ plotCapEnergy(params.C ?? 1e-6, params.Vmax ?? 10); }
  else if(type === 'li_energy'){ plotIndEnergy(params.L ?? 0.1, params.Imax ?? 2.0); }
}

function renderQuestion(){
  resetState();
  const q = questions[idx];
  elQNum.textContent = (idx+1).toString();
  elQ.innerHTML = q.text;
  renderPlot(q.plot);
  q.choices.forEach((opt, i)=>{
    const b = document.createElement('button');
    b.className = 'option';
    b.innerHTML = opt;
    b.addEventListener('click', ()=>onChoose(i));
    elOptions.appendChild(b);
  });
  // Update progress bar to reflect question index (before answering)
  elBar.style.width = `${(idx)/questions.length*100}%`;
  renderMath();
}

function onChoose(i){
  if(answeredThis) return;
  answeredThis = true;
  const q = questions[idx];
  const nodes = [...document.querySelectorAll('.option')];
  nodes.forEach((n,k)=>{
    if(k === q.correctIndex){ n.classList.add('correct'); }
    if(k === i && k !== q.correctIndex){ n.classList.add('wrong'); }
    n.disabled = true;
  });
  const correct = i === q.correctIndex;
  if(correct) score++;
  elScore.textContent = score.toString();
  elExplain.style.display = 'block';
  elExplain.innerHTML = `<span class="math">${q.explain}</span>`;
  renderMath();
  elFooter.textContent = correct ? "Nice! Correct answer." : "Review the explanation above.";
}

// Next also acts as Skip: always enabled, advances even if no option chosen
elNext.addEventListener('click', ()=>{
  idx++;
  if(idx >= questions.length){
    elQ.innerHTML = `Game complete! Final score: <span class="score">${score}</span> / ${questions.length}`;
    elOptions.innerHTML = '';
    elExplain.style.display = 'none';
    elPlotWrap.style.display = 'none';
    elNext.style.display = 'none';
    elRestart.style.display = 'inline-block';
    elBar.style.width = '100%';
  }else{
    renderQuestion();
  }
});

elRestart.addEventListener('click', ()=>{
  idx = 0; score = 0;
  elScore.textContent = '0';
  elNext.style.display = 'inline-block';
  elRestart.style.display = 'none';
  renderQuestion();
});

// initial render
renderQuestion();
</script>
</body>
</html>
