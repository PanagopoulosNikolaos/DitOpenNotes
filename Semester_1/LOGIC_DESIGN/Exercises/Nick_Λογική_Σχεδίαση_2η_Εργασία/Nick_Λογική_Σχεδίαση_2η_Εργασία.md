## Κώδικες και μετατροπές

### Υλικά Άσκησης

- 1 IC 7404 (Hex Inverters)
- 1 IC 7408 (Quad 2-input AND Gate)
- 1 IC 7432 (Quad 2-input OR Gate)
- 1 IC 7486 (Quad 2-input exclusive OR)

### 1ο Μέρος: Μετατροπή κώδικα Gray σε δυαδικό

Υλοποιήστε ένα συνδυαστικό κύκλωμα με 4 εισόδους και 4 εξόδους που να μετατρέπει έναν 4-bit αριθμό κώδικα Gray στον ισοδύναμο 4bit δυαδικό αριθμό. Να σχηματίσετε τον πίνακα μετατροπής κώδικα Gray σε δυαδικό. Σχεδιάστε το λογικό διάγραμμα χρησιμοποιώντας μόνο πύλες XOR. Υλοποιήστε και επιβεβαιώστε την σωστή λειτουργία του.

### 2ο Μέρος: Συμπλήρωμα ως προς 9

Σχεδιάστε ένα συνδυαστικό κύκλωμα με 4 εισόδους που παριστάνουν ένα δεκαδικό ψηφίο σε κώδικα BCD και με 4 εξόδους που δίνουν το συμπλήρωμα ως προς 9 του ψηφίου εισόδου. Με μια επιπλέον έξοδο δώστε την δυνατότητα ανίχνευσης εσφαλμένων εισόδων (μη κωδικών).

---

  

### Μέρος 1: Μετατροπή κώδικα Gray σε δυαδικό

Για να υλοποιήσουμε ένα συνδυαστικό κύκλωμα που μετατρέπει έναν 4-bit κώδικα Gray στον ισοδύναμο 4-bit δυαδικό αριθμό, ακολουθούμε τα εξής βήματα:

**Πίνακας μετατροπής κώδικα Gray σε δυαδικό:**

---

# 1ο Μέρος: Μετατροπή κώδικα Gray σε δυαδικό

|   |   |   |   |   |
|---|---|---|---|---|
|Decimal|G3|G2|G1|G0|
|0|0|0|0|0|
|1|0|0|0|1|
|2|0|0|1|1|
|3|0|0|1|0|
|4|0|1|1|0|
|5|0|1|1|1|
|6|0|1|0|1|
|7|0|1|0|0|
|8|1|1|0|0|
|9|1|1|0|1|
|10|1|1|1|1|
|11|1|1|1|0|
|12|1|0|1|0|
|13|1|0|1|1|
|14|1|0|0|1|
|15|1|0|0|0|
|Hex|00FF|0F0F|3333|5555|

---

**Χάρτης Karnaugh για τη μετατροπή:**

```undefined
G3G2\G1G0  00   01   11   10
    00     0000 0001 0011 0010
    01     0110 0111 0101 0100
    11     1100 1101 1111 1110
    10     1010 1011 1001 1000
```

---

# Αντιστοιχία Δυαδικού - Gray Code

|   |   |   |
|---|---|---|
|**Δεκαδικός**|**Δυαδικός**|**Gray Code**|
|0|0000|0000|
|1|0001|0001|
|2|0010|0011|
|3|0011|0010|
|4|0100|0110|
|5|0101|0111|
|6|0110|0101|
|7|0111|0100|
|8|1000|1100|
|9|1001|1101|
|10|1010|1111|
|11|1011|1110|
|12|1100|1010|
|13|1101|1011|
|14|1110|1001|
|15|1111|1000|

  

---

```Mermaid
graph TD
    subgraph "Μέρος 1: Μετατροπή κώδικα Gray σε δυαδικό"
    
    
    
        G3 --> B3
        G3 --> XOR1
        G2 --> XOR1
        XOR1 --> B2
        B2 --> XOR2
        G1 --> XOR2
        XOR2 --> B1
        B1 --> XOR3
        G0 --> XOR3
        XOR3 --> B0
    end


    
    classDef default fill:\#f9f,stroke:#333,stroke-width:2px;
    classDef xor fill:\#ff9,stroke:#333,stroke-width:2px;

    class XOR1,XOR2,XOR3 xor;
```

---

  

**Σχεδιασμός με πύλες XOR:**

Η μετατροπή από Gray σε δυαδικό γίνεται ως εξής:

- Το πιο σημαντικό bit του δυαδικού αριθμού (B3) είναι ίδιο με το πιο σημαντικό bit του κώδικα Gray (G3).
- Κάθε επόμενο δυαδικό bit είναι το αποτέλεσμα της πράξης XOR μεταξύ του προηγούμενου δυαδικού bit και του αντίστοιχου bit του κώδικα Gray.

**Εξισώσεις:**

- **B3 = G3**
- **B2 = B3 XOR G2**
- **B1 = B2 XOR G1**
- **B0 = B1 XOR G0**

**Λογικό διάγραμμα:**

- Χρησιμοποιούμε πύλες XOR για τις πράξεις.
- Έχουμε μία πύλη XOR για κάθε εξίσωση B2, B1, B0.
- Το B3 συνδέεται απευθείας με το G3.

**Υλοποίηση:**

Με το IC 7486 (Quad 2-input XOR Gate), μπορούμε να υλοποιήσουμε τις απαιτούμενες πύλες XOR.

![[/image 39.png|image 39.png]]

![[/image 1 6.png|image 1 6.png]]

---

  

# Μέρος 2: Συμπλήρωμα ως προς 9

**Σχεδιασμός κυκλώματος:**

- Το κύκλωμα δέχεται ένα 4-bit BCD ψηφίο (D3 D2 D1 D0).
- Παράγει το συμπλήρωμα ως προς 9 του ψηφίου εισόδου.
- Εντοπίζει μη έγκυρες BCD εισόδους (τιμές από 1010 έως 1111).

---

### Υπολογισμός του συμπληρώματος ως προς 9

Το συμπλήρωμα ως προς 9 ενός δεκαδικού ψηφίου $D$ είναι:

$C = 9 - D$

---

### Πίνακας Αληθείας

|   |   |   |
|---|---|---|
|**D3 D2 D1 D0 (D)**|**C3 C2 C1 C0 (C)**|**Error**|
|0000 (0)|1001 (9)|0|
|0001 (1)|1000 (8)|0|
|0010 (2)|0111 (7)|0|
|0011 (3)|0110 (6)|0|
|0100 (4)|0101 (5)|0|
|0101 (5)|0100 (4)|0|
|0110 (6)|0011 (3)|0|
|0111 (7)|0010 (2)|0|
|1000 (8)|0001 (1)|0|
|1001 (9)|0000 (0)|0|
|**1010**|X|**1**|
|**1011**|X|**1**|
|**1100**|X|**1**|
|**1101**|X|**1**|
|**1110**|X|**1**|
|**1111**|X|**1**|

- Για τιμές από $D = [1010, ..., 1111]$, το Error είναι ενεργό ($Error = 1$).

---

### Χάρτες Karnaugh

Για C3:

```undefined
D3D2\D1D0 00  01  11  10
      00   1   1   1   1
      01   1   1   1   1
      11   0   0   0   0
      10   0   0   0   0
```

Για C2:

```undefined
D3D2\D1D0 00  01  11  10
      00   1   1   1   1
      01   0   0   0   0
      11   0   0   0   0
      10   1   1   1   1
```

Για C1:

```undefined
D3D2\D1D0 00  01  11  10
      00   1   1   0   0
      01   1   1   0   0
      11   1   1   0   0
      10   1   1   0   0
```

Για C0:

```undefined
D3D2\D1D0 00  01  11  10
      00   1   0   0   1
      01   1   0   0   1
      11   1   0   0   1
      10   1   0   0   1
```

### Συναρτήσεις

### Υπολογισμός του συμπληρώματος ως προς το 9:

Οι εξισώσεις για $C3, C2, C1, C0$:

- $C3 = \overline{D3} + (\overline{D2} \cdot \overline{D1} \cdot \overline{D0})$
- $C2 = \overline{D2} + (\overline{D3} \cdot D2 \cdot \overline{D1})$
- $C1 = \overline{D1} + (\overline{D3} \cdot D2 \cdot D1 \cdot \overline{D0})$
- $C0 = \overline{D0}$

### Ανίχνευση σφάλματος:

Η εξίσωση για την έξοδο σφάλματος:  
$Error = D3 \cdot (D2 + D1 + D0)$

---

### Μορφή σε Hexadecimal για κάθε σήμα

### Είσοδοι:

- $D_0: \texttt{0000000000001111} = \texttt{0x000F}$
- $D_1: \texttt{0000000011110000} = \texttt{0x00F0}$
- $D_2: \texttt{0000111100001111} = \texttt{0x0F0F}$
- $D_3: \texttt{1111000011110000} = \texttt{0xF0F0}$

### Έξοδοι:

- $C_0: \texttt{1111111111110000} = \texttt{FFF0}$
- $C_1: \texttt{1111000011110000} = \texttt{F0F0}$
- $C_2: \texttt{1100110011001100} = \texttt{CCCC}$
- $C_3: \texttt{1001100110011001} = \texttt{9999}$

### Error:

$\texttt{Error: } =\texttt{00FF}$

---

### Διάγραμμα Mermaid

```Mermaid
graph TD
    subgraph "Input Sequences"
        D0[D0 Sequence]
        D1[D1 Sequence]
        D2[D2 Sequence]
        D3[D3 Sequence]
    end

    subgraph "Logic Gates"
        direction LR
        D0 --> OR1[OR Gate 1]
        D1 --> OR1
        D2 --> OR2[OR Gate 2]
        OR1 --> OR2
        
        D3 --> AND1[AND Gate 1]
        OR2 --> AND1

        D0 --> COMP[Complement Logic]
        D1 --> COMP
        D2 --> COMP
        D3 --> COMP
    end

    subgraph "Output Lights"
        COMP --> C0[C0 Output]
        COMP --> C1[C1 Output]
        COMP --> C2[C2 Output]
        COMP --> C3[C3 Output]
        AND1 --> ERR[Error Light]
    end

    classDef sequence fill:\#e1f5fe,stroke:\#01579b,stroke-width:2px;
    classDef gate fill:\#fff3e0,stroke:\#e65100,stroke-width:2px;
    classDef output fill:\#f1f8e9,stroke:\#33691e,stroke-width:2px;
    
    class D0,D1,D2,D3 sequence;
    class OR1,OR2,AND1,COMP gate;
    class C0,C1,C2,C3,ERR output;
```

```Mermaid
graph TD
    subgraph "Συμπλήρωμα ως προς 9 και Ανίχνευση Σφάλματος"
        D3 --> NOT3[NOT]
        D2 --> NOT2[NOT]
        D1 --> NOT1[NOT]
        D0 --> NOT0[NOT]
        
        NOT3 --> C3
        NOT2 --> C2
        NOT1 --> C1
        NOT0 --> C0
        
        D2 --> OR1[OR]
        D1 --> OR1
        OR1 --> OR2[OR]
        D0 --> OR2
        
        D3 --> AND1[AND]
        OR2 --> AND1
        
        AND1 --> Error
    end
    
    classDef default fill:\#f9f,stroke:#333,stroke-width:2px;
    classDef not fill:\#ff9,stroke:#333,stroke-width:2px;
    classDef or fill:\#9ff,stroke:#333,stroke-width:2px;
    classDef and fill:\#f99,stroke:#333,stroke-width:2px;
    
    class NOT0,NOT1,NOT2,NOT3 not;
    class OR1,OR2 or;
    class AND1 and;
```

---

![[/image 2 6.png|image 2 6.png]]

---

![[/image 3 4.png|image 3 4.png]]